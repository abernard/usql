/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : SQL92.g
 *     -                            On : 2011-10-06 04:06:35
 *     -                 for the lexer : SQL92LexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/******************************************************************
*
* uSQL for C++
*
* SQL92Lexer for ANTLR
*
* Copyright (C) Satoshi Konno 2011
*
* This is licensed under BSD-style license, see file COPYING.
*
******************************************************************/

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SQL92Lexer.h"
/* ----------------------------------------- */


/** String literals used by SQL92Lexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSQL92Lexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSQL92Lexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSQL92Lexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSQL92Lexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER
#undef	    RULEMEMO
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define	    NEXTCHAR	((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR	((pANTLR3_UINT16)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()   INPUT->istream->consume(INPUT->istream)
#define	    LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE 
 void
	mCOMMENT    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mA    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mB    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mC    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mD    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mE    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mF    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mG    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mH    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mI    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mJ    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mK    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mL    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mM    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mN    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mO    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mP    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mQ    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mR    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mS    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mT    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mU    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mV    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mW    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mX    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mY    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mZ    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mADD    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mALL    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mALLOCATE    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mALTER    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mAND    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mANY    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mARE    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mAS    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mASC    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mASSERTION    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mAT    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mAUTHORIZATION    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mAVG    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mBEGIN    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mBETWEEN    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mBIGINT    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mBIT    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mBOOLEAN    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mBOTH    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mBY    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mCALL    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mCASCADE    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mCASCADED    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mCASE    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mCAST    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mCHARACTER    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mFROM    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mSELECT    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mWHERE    (pSQL92Lexer ctx);
static ANTLR3_INLINE 
 void
	mTokens    (pSQL92Lexer ctx);
static void	SQL92LexerFree(pSQL92Lexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
SQL92LexerFree  (pSQL92Lexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

static void
SQL92LexerReset (pSQL92Lexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SQL92.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called SQL92Lexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pSQL92Lexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pSQL92Lexer SQL92LexerNew
(
pANTLR3_INPUT_STREAM
 instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return SQL92LexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called SQL92Lexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pSQL92Lexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pSQL92Lexer SQL92LexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSQL92Lexer ctx; // Context structure we will build and return

    ctx = (pSQL92Lexer) ANTLR3_CALLOC(1, sizeof(SQL92Lexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SQL92Lexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our SQL92Lexer interface
     */
    ctx->mCOMMENT	= mCOMMENT;
    ctx->mA	= mA;
    ctx->mB	= mB;
    ctx->mC	= mC;
    ctx->mD	= mD;
    ctx->mE	= mE;
    ctx->mF	= mF;
    ctx->mG	= mG;
    ctx->mH	= mH;
    ctx->mI	= mI;
    ctx->mJ	= mJ;
    ctx->mK	= mK;
    ctx->mL	= mL;
    ctx->mM	= mM;
    ctx->mN	= mN;
    ctx->mO	= mO;
    ctx->mP	= mP;
    ctx->mQ	= mQ;
    ctx->mR	= mR;
    ctx->mS	= mS;
    ctx->mT	= mT;
    ctx->mU	= mU;
    ctx->mV	= mV;
    ctx->mW	= mW;
    ctx->mX	= mX;
    ctx->mY	= mY;
    ctx->mZ	= mZ;
    ctx->mADD	= mADD;
    ctx->mALL	= mALL;
    ctx->mALLOCATE	= mALLOCATE;
    ctx->mALTER	= mALTER;
    ctx->mAND	= mAND;
    ctx->mANY	= mANY;
    ctx->mARE	= mARE;
    ctx->mAS	= mAS;
    ctx->mASC	= mASC;
    ctx->mASSERTION	= mASSERTION;
    ctx->mAT	= mAT;
    ctx->mAUTHORIZATION	= mAUTHORIZATION;
    ctx->mAVG	= mAVG;
    ctx->mBEGIN	= mBEGIN;
    ctx->mBETWEEN	= mBETWEEN;
    ctx->mBIGINT	= mBIGINT;
    ctx->mBIT	= mBIT;
    ctx->mBOOLEAN	= mBOOLEAN;
    ctx->mBOTH	= mBOTH;
    ctx->mBY	= mBY;
    ctx->mCALL	= mCALL;
    ctx->mCASCADE	= mCASCADE;
    ctx->mCASCADED	= mCASCADED;
    ctx->mCASE	= mCASE;
    ctx->mCAST	= mCAST;
    ctx->mCHARACTER	= mCHARACTER;
    ctx->mFROM	= mFROM;
    ctx->mSELECT	= mSELECT;
    ctx->mWHERE	= mWHERE;
    ctx->mTokens	= mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= SQL92LexerFree;
    ctx->reset          = SQL92LexerReset;


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}
/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 99:2: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COMMENT;


    {
        //  SQL92.g:99:2: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )

        ANTLR3_UINT32 alt4;

        alt4=2;

        switch ( LA(1) )
        {
        case '/':
        	{
        		switch ( LA(2) )
        		{
        		case '/':
        			{
        				alt4=1;
        			}
        		    break;
        		case '*':
        			{
        				alt4=2;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 4;
        		    EXCEPTION->state        = 1;


        		    goto ruleCOMMENTEx;

        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 4;
            EXCEPTION->state        = 0;


            goto ruleCOMMENTEx;

        }

        switch (alt4)
        {
    	case 1:
    	    // SQL92.g:99:6: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    	    {
    	        MATCHS(lit_1);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // SQL92.g:99:11: (~ ( '\\n' | '\\r' ) )*

    	        for (;;)
    	        {
    	            int alt1=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA1_0 = LA(1);
    	                if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '\t')) || ((LA1_0 >= 0x000B) && (LA1_0 <= '\f')) || ((LA1_0 >= 0x000E) && (LA1_0 <= 0xFFFF))))
    	                {
    	                    alt1=1;
    	                }

    	            }
    	            switch (alt1)
    	            {
    	        	case 1:
    	        	    // SQL92.g:
    	        	    {
    	        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
    	        	        {
    	        	            CONSUME();
    	        	        }
    	        	        else
    	        	        {
    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop1;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop1: ; /* Jump out to here if this rule does not match */


    	        // SQL92.g:99:25: ( '\\r' )?
    	        {
    	            int alt2=2;
    	            switch ( LA(1) )
    	            {
    	                case '\r':
    	                	{
    	                		alt2=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt2)
    	            {
    	        	case 1:
    	        	    // SQL92.g:99:25: '\\r'
    	        	    {
    	        	        MATCHC('\r');
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	        MATCHC('\n');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleCOMMENTEx;
    	        }


    	        {
    	            LEXSTATE->channel=HIDDEN;
    	        }


    	    }
    	    break;
    	case 2:
    	    // SQL92.g:100:6: '/*' ( options {greedy=false; } : . )* '*/'
    	    {
    	        MATCHS(lit_2);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // SQL92.g:100:11: ( options {greedy=false; } : . )*

    	        for (;;)
    	        {
    	            int alt3=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA3_0 = LA(1);
    	                if ( (LA3_0 == '*'))
    	                {
    	                    {
    	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                        */
    	                        int LA3_1 = LA(2);
    	                        if ( (LA3_1 == '/'))
    	                        {
    	                            alt3=2;
    	                        }
    	                        else if ( (((LA3_1 >= 0x0000) && (LA3_1 <= '.')) || ((LA3_1 >= '0') && (LA3_1 <= 0xFFFF))))
    	                        {
    	                            alt3=1;
    	                        }

    	                    }
    	                }
    	                else if ( (((LA3_0 >= 0x0000) && (LA3_0 <= ')')) || ((LA3_0 >= '+') && (LA3_0 <= 0xFFFF))))
    	                {
    	                    alt3=1;
    	                }

    	            }
    	            switch (alt3)
    	            {
    	        	case 1:
    	        	    // SQL92.g:100:39: .
    	        	    {
    	        	        MATCHANY();
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop3;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop3: ; /* Jump out to here if this rule does not match */


    	        MATCHS(lit_3);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        {
    	            LEXSTATE->channel=HIDDEN;
    	        }


    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 149:3: ( 'A' | 'a' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start A
 *
 * Looks to match the characters the constitute the token A
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mA(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:149:3: ( 'A' | 'a' )
    // SQL92.g:
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleAEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleAEx; /* Prevent compiler warnings */
    ruleAEx: ;

}
// $ANTLR end A

//   Comes from: 154:3: ( 'B' | 'b' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start B
 *
 * Looks to match the characters the constitute the token B
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mB(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:154:3: ( 'B' | 'b' )
    // SQL92.g:
    {
        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleBEx; /* Prevent compiler warnings */
    ruleBEx: ;

}
// $ANTLR end B

//   Comes from: 159:3: ( 'C' | 'c' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start C
 *
 * Looks to match the characters the constitute the token C
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mC(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:159:3: ( 'C' | 'c' )
    // SQL92.g:
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleCEx; /* Prevent compiler warnings */
    ruleCEx: ;

}
// $ANTLR end C

//   Comes from: 164:3: ( 'D' | 'd' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start D
 *
 * Looks to match the characters the constitute the token D
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mD(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:164:3: ( 'D' | 'd' )
    // SQL92.g:
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleDEx; /* Prevent compiler warnings */
    ruleDEx: ;

}
// $ANTLR end D

//   Comes from: 169:3: ( 'E' | 'e' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start E
 *
 * Looks to match the characters the constitute the token E
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mE(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:169:3: ( 'E' | 'e' )
    // SQL92.g:
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleEEx; /* Prevent compiler warnings */
    ruleEEx: ;

}
// $ANTLR end E

//   Comes from: 174:3: ( 'F' | 'f' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start F
 *
 * Looks to match the characters the constitute the token F
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mF(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:174:3: ( 'F' | 'f' )
    // SQL92.g:
    {
        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleFEx; /* Prevent compiler warnings */
    ruleFEx: ;

}
// $ANTLR end F

//   Comes from: 179:3: ( 'G' | 'g' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start G
 *
 * Looks to match the characters the constitute the token G
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mG(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:179:3: ( 'G' | 'g' )
    // SQL92.g:
    {
        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleGEx; /* Prevent compiler warnings */
    ruleGEx: ;

}
// $ANTLR end G

//   Comes from: 184:3: ( 'H' | 'h' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H
 *
 * Looks to match the characters the constitute the token H
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:184:3: ( 'H' | 'h' )
    // SQL92.g:
    {
        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleHEx; /* Prevent compiler warnings */
    ruleHEx: ;

}
// $ANTLR end H

//   Comes from: 189:3: ( 'I' | 'i' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start I
 *
 * Looks to match the characters the constitute the token I
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mI(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:189:3: ( 'I' | 'i' )
    // SQL92.g:
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleIEx; /* Prevent compiler warnings */
    ruleIEx: ;

}
// $ANTLR end I

//   Comes from: 194:3: ( 'J' | 'j' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start J
 *
 * Looks to match the characters the constitute the token J
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mJ(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:194:3: ( 'J' | 'j' )
    // SQL92.g:
    {
        if ( LA(1) == 'J' || LA(1) == 'j' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleJEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleJEx; /* Prevent compiler warnings */
    ruleJEx: ;

}
// $ANTLR end J

//   Comes from: 199:3: ( 'K' | 'k' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start K
 *
 * Looks to match the characters the constitute the token K
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mK(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:199:3: ( 'K' | 'k' )
    // SQL92.g:
    {
        if ( LA(1) == 'K' || LA(1) == 'k' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleKEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleKEx; /* Prevent compiler warnings */
    ruleKEx: ;

}
// $ANTLR end K

//   Comes from: 204:3: ( 'L' | 'l' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start L
 *
 * Looks to match the characters the constitute the token L
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mL(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:204:3: ( 'L' | 'l' )
    // SQL92.g:
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleLEx; /* Prevent compiler warnings */
    ruleLEx: ;

}
// $ANTLR end L

//   Comes from: 209:3: ( 'M' | 'm' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start M
 *
 * Looks to match the characters the constitute the token M
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mM(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:209:3: ( 'M' | 'm' )
    // SQL92.g:
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleMEx; /* Prevent compiler warnings */
    ruleMEx: ;

}
// $ANTLR end M

//   Comes from: 214:3: ( 'N' | 'n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start N
 *
 * Looks to match the characters the constitute the token N
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mN(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:214:3: ( 'N' | 'n' )
    // SQL92.g:
    {
        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleNEx; /* Prevent compiler warnings */
    ruleNEx: ;

}
// $ANTLR end N

//   Comes from: 219:3: ( 'O' | 'o' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start O
 *
 * Looks to match the characters the constitute the token O
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mO(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:219:3: ( 'O' | 'o' )
    // SQL92.g:
    {
        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleOEx; /* Prevent compiler warnings */
    ruleOEx: ;

}
// $ANTLR end O

//   Comes from: 224:3: ( 'P' | 'p' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start P
 *
 * Looks to match the characters the constitute the token P
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mP(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:224:3: ( 'P' | 'p' )
    // SQL92.g:
    {
        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto rulePEx; /* Prevent compiler warnings */
    rulePEx: ;

}
// $ANTLR end P

//   Comes from: 229:3: ( 'Q' | 'q' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start Q
 *
 * Looks to match the characters the constitute the token Q
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQ(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:229:3: ( 'Q' | 'q' )
    // SQL92.g:
    {
        if ( LA(1) == 'Q' || LA(1) == 'q' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleQEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQEx; /* Prevent compiler warnings */
    ruleQEx: ;

}
// $ANTLR end Q

//   Comes from: 234:3: ( 'R' | 'r' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start R
 *
 * Looks to match the characters the constitute the token R
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mR(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:234:3: ( 'R' | 'r' )
    // SQL92.g:
    {
        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleREx; /* Prevent compiler warnings */
    ruleREx: ;

}
// $ANTLR end R

//   Comes from: 239:3: ( 'S' | 's' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start S
 *
 * Looks to match the characters the constitute the token S
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mS(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:239:3: ( 'S' | 's' )
    // SQL92.g:
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleSEx; /* Prevent compiler warnings */
    ruleSEx: ;

}
// $ANTLR end S

//   Comes from: 244:3: ( 'T' | 't' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T
 *
 * Looks to match the characters the constitute the token T
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:244:3: ( 'T' | 't' )
    // SQL92.g:
    {
        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleTEx; /* Prevent compiler warnings */
    ruleTEx: ;

}
// $ANTLR end T

//   Comes from: 249:3: ( 'U' | 'u' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start U
 *
 * Looks to match the characters the constitute the token U
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mU(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:249:3: ( 'U' | 'u' )
    // SQL92.g:
    {
        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleUEx; /* Prevent compiler warnings */
    ruleUEx: ;

}
// $ANTLR end U

//   Comes from: 254:3: ( 'V' | 'v' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start V
 *
 * Looks to match the characters the constitute the token V
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mV(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:254:3: ( 'V' | 'v' )
    // SQL92.g:
    {
        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleVEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleVEx; /* Prevent compiler warnings */
    ruleVEx: ;

}
// $ANTLR end V

//   Comes from: 259:3: ( 'W' | 'w' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start W
 *
 * Looks to match the characters the constitute the token W
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mW(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:259:3: ( 'W' | 'w' )
    // SQL92.g:
    {
        if ( LA(1) == 'W' || LA(1) == 'w' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleWEx; /* Prevent compiler warnings */
    ruleWEx: ;

}
// $ANTLR end W

//   Comes from: 264:3: ( 'X' | 'x' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start X
 *
 * Looks to match the characters the constitute the token X
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mX(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:264:3: ( 'X' | 'x' )
    // SQL92.g:
    {
        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleXEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleXEx; /* Prevent compiler warnings */
    ruleXEx: ;

}
// $ANTLR end X

//   Comes from: 269:3: ( 'Y' | 'y' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start Y
 *
 * Looks to match the characters the constitute the token Y
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mY(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:269:3: ( 'Y' | 'y' )
    // SQL92.g:
    {
        if ( LA(1) == 'Y' || LA(1) == 'y' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleYEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleYEx; /* Prevent compiler warnings */
    ruleYEx: ;

}
// $ANTLR end Y

//   Comes from: 274:3: ( 'Z' | 'z' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start Z
 *
 * Looks to match the characters the constitute the token Z
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mZ(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;


    // SQL92.g:274:3: ( 'Z' | 'z' )
    // SQL92.g:
    {
        if ( LA(1) == 'Z' || LA(1) == 'z' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleZEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleZEx; /* Prevent compiler warnings */
    ruleZEx: ;

}
// $ANTLR end Z

//   Comes from: 279:2: ( A D D )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ADD
 *
 * Looks to match the characters the constitute the token ADD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mADD(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ADD;


    // SQL92.g:279:2: ( A D D )
    // SQL92.g:279:4: A D D
    {
        /* 279:4: A D D */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleADDEx;
        }



        /* 279:4: A D D */
        mD(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleADDEx;
        }



        /* 279:4: A D D */
        mD(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleADDEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleADDEx; /* Prevent compiler warnings */
    ruleADDEx: ;

}
// $ANTLR end ADD

//   Comes from: 283:2: ( A L L )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALL
 *
 * Looks to match the characters the constitute the token ALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mALL(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ALL;


    // SQL92.g:283:2: ( A L L )
    // SQL92.g:283:4: A L L
    {
        /* 283:4: A L L */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLEx;
        }



        /* 283:4: A L L */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLEx;
        }



        /* 283:4: A L L */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleALLEx; /* Prevent compiler warnings */
    ruleALLEx: ;

}
// $ANTLR end ALL

//   Comes from: 287:2: ( A L L O C A T E )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALLOCATE
 *
 * Looks to match the characters the constitute the token ALLOCATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mALLOCATE(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ALLOCATE;


    // SQL92.g:287:2: ( A L L O C A T E )
    // SQL92.g:287:4: A L L O C A T E
    {
        /* 287:4: A L L O C A T E */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLOCATEEx;
        }



        /* 287:4: A L L O C A T E */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLOCATEEx;
        }



        /* 287:4: A L L O C A T E */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLOCATEEx;
        }



        /* 287:4: A L L O C A T E */
        mO(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLOCATEEx;
        }



        /* 287:4: A L L O C A T E */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLOCATEEx;
        }



        /* 287:4: A L L O C A T E */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLOCATEEx;
        }



        /* 287:4: A L L O C A T E */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLOCATEEx;
        }



        /* 287:4: A L L O C A T E */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALLOCATEEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleALLOCATEEx; /* Prevent compiler warnings */
    ruleALLOCATEEx: ;

}
// $ANTLR end ALLOCATE

//   Comes from: 291:2: ( A L T E R )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALTER
 *
 * Looks to match the characters the constitute the token ALTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mALTER(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ALTER;


    // SQL92.g:291:2: ( A L T E R )
    // SQL92.g:291:4: A L T E R
    {
        /* 291:4: A L T E R */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALTEREx;
        }



        /* 291:4: A L T E R */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALTEREx;
        }



        /* 291:4: A L T E R */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALTEREx;
        }



        /* 291:4: A L T E R */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALTEREx;
        }



        /* 291:4: A L T E R */
        mR(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleALTEREx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleALTEREx; /* Prevent compiler warnings */
    ruleALTEREx: ;

}
// $ANTLR end ALTER

//   Comes from: 295:2: ( A N D )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AND
 *
 * Looks to match the characters the constitute the token AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAND(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AND;


    // SQL92.g:295:2: ( A N D )
    // SQL92.g:295:4: A N D
    {
        /* 295:4: A N D */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleANDEx;
        }



        /* 295:4: A N D */
        mN(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleANDEx;
        }



        /* 295:4: A N D */
        mD(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleANDEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleANDEx; /* Prevent compiler warnings */
    ruleANDEx: ;

}
// $ANTLR end AND

//   Comes from: 299:2: ( A N Y )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ANY
 *
 * Looks to match the characters the constitute the token ANY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mANY(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ANY;


    // SQL92.g:299:2: ( A N Y )
    // SQL92.g:299:4: A N Y
    {
        /* 299:4: A N Y */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleANYEx;
        }



        /* 299:4: A N Y */
        mN(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleANYEx;
        }



        /* 299:4: A N Y */
        mY(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleANYEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleANYEx; /* Prevent compiler warnings */
    ruleANYEx: ;

}
// $ANTLR end ANY

//   Comes from: 303:2: ( A R E )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ARE
 *
 * Looks to match the characters the constitute the token ARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mARE(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ARE;


    // SQL92.g:303:2: ( A R E )
    // SQL92.g:303:4: A R E
    {
        /* 303:4: A R E */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAREEx;
        }



        /* 303:4: A R E */
        mR(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAREEx;
        }



        /* 303:4: A R E */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAREEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleAREEx; /* Prevent compiler warnings */
    ruleAREEx: ;

}
// $ANTLR end ARE

//   Comes from: 307:2: ( A S )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AS
 *
 * Looks to match the characters the constitute the token AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAS(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AS;


    // SQL92.g:307:2: ( A S )
    // SQL92.g:307:4: A S
    {
        /* 307:4: A S */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASEx;
        }



        /* 307:4: A S */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleASEx; /* Prevent compiler warnings */
    ruleASEx: ;

}
// $ANTLR end AS

//   Comes from: 311:2: ( A S C )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASC
 *
 * Looks to match the characters the constitute the token ASC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mASC(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ASC;


    // SQL92.g:311:2: ( A S C )
    // SQL92.g:311:4: A S C
    {
        /* 311:4: A S C */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASCEx;
        }



        /* 311:4: A S C */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASCEx;
        }



        /* 311:4: A S C */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASCEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleASCEx; /* Prevent compiler warnings */
    ruleASCEx: ;

}
// $ANTLR end ASC

//   Comes from: 315:2: ( A S S E R T I O N )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASSERTION
 *
 * Looks to match the characters the constitute the token ASSERTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mASSERTION(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ASSERTION;


    // SQL92.g:315:2: ( A S S E R T I O N )
    // SQL92.g:315:4: A S S E R T I O N
    {
        /* 315:4: A S S E R T I O N */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



        /* 315:4: A S S E R T I O N */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



        /* 315:4: A S S E R T I O N */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



        /* 315:4: A S S E R T I O N */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



        /* 315:4: A S S E R T I O N */
        mR(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



        /* 315:4: A S S E R T I O N */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



        /* 315:4: A S S E R T I O N */
        mI(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



        /* 315:4: A S S E R T I O N */
        mO(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



        /* 315:4: A S S E R T I O N */
        mN(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleASSERTIONEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleASSERTIONEx; /* Prevent compiler warnings */
    ruleASSERTIONEx: ;

}
// $ANTLR end ASSERTION

//   Comes from: 319:2: ( A T )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AT
 *
 * Looks to match the characters the constitute the token AT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAT(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AT;


    // SQL92.g:319:2: ( A T )
    // SQL92.g:319:4: A T
    {
        /* 319:4: A T */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleATEx;
        }



        /* 319:4: A T */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleATEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleATEx; /* Prevent compiler warnings */
    ruleATEx: ;

}
// $ANTLR end AT

//   Comes from: 323:2: ( A U T H O R I Z A T I O N )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AUTHORIZATION
 *
 * Looks to match the characters the constitute the token AUTHORIZATION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAUTHORIZATION(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AUTHORIZATION;


    // SQL92.g:323:2: ( A U T H O R I Z A T I O N )
    // SQL92.g:323:4: A U T H O R I Z A T I O N
    {
        /* 323:4: A U T H O R I Z A T I O N */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mU(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mH(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mO(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mR(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mI(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mZ(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mI(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mO(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



        /* 323:4: A U T H O R I Z A T I O N */
        mN(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAUTHORIZATIONEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleAUTHORIZATIONEx; /* Prevent compiler warnings */
    ruleAUTHORIZATIONEx: ;

}
// $ANTLR end AUTHORIZATION

//   Comes from: 327:2: ( A V G )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AVG
 *
 * Looks to match the characters the constitute the token AVG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAVG(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AVG;


    // SQL92.g:327:2: ( A V G )
    // SQL92.g:327:4: A V G
    {
        /* 327:4: A V G */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAVGEx;
        }



        /* 327:4: A V G */
        mV(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAVGEx;
        }



        /* 327:4: A V G */
        mG(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleAVGEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleAVGEx; /* Prevent compiler warnings */
    ruleAVGEx: ;

}
// $ANTLR end AVG

//   Comes from: 331:2: ( B E G I N )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BEGIN
 *
 * Looks to match the characters the constitute the token BEGIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBEGIN(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BEGIN;


    // SQL92.g:331:2: ( B E G I N )
    // SQL92.g:331:4: B E G I N
    {
        /* 331:4: B E G I N */
        mB(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBEGINEx;
        }



        /* 331:4: B E G I N */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBEGINEx;
        }



        /* 331:4: B E G I N */
        mG(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBEGINEx;
        }



        /* 331:4: B E G I N */
        mI(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBEGINEx;
        }



        /* 331:4: B E G I N */
        mN(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBEGINEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBEGINEx; /* Prevent compiler warnings */
    ruleBEGINEx: ;

}
// $ANTLR end BEGIN

//   Comes from: 335:2: ( B E T W E E N )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BETWEEN
 *
 * Looks to match the characters the constitute the token BETWEEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBETWEEN(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BETWEEN;


    // SQL92.g:335:2: ( B E T W E E N )
    // SQL92.g:335:4: B E T W E E N
    {
        /* 335:4: B E T W E E N */
        mB(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBETWEENEx;
        }



        /* 335:4: B E T W E E N */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBETWEENEx;
        }



        /* 335:4: B E T W E E N */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBETWEENEx;
        }



        /* 335:4: B E T W E E N */
        mW(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBETWEENEx;
        }



        /* 335:4: B E T W E E N */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBETWEENEx;
        }



        /* 335:4: B E T W E E N */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBETWEENEx;
        }



        /* 335:4: B E T W E E N */
        mN(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBETWEENEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBETWEENEx; /* Prevent compiler warnings */
    ruleBETWEENEx: ;

}
// $ANTLR end BETWEEN

//   Comes from: 339:2: ( B I G I N T )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIGINT
 *
 * Looks to match the characters the constitute the token BIGINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBIGINT(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BIGINT;


    // SQL92.g:339:2: ( B I G I N T )
    // SQL92.g:339:4: B I G I N T
    {
        /* 339:4: B I G I N T */
        mB(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBIGINTEx;
        }



        /* 339:4: B I G I N T */
        mI(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBIGINTEx;
        }



        /* 339:4: B I G I N T */
        mG(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBIGINTEx;
        }



        /* 339:4: B I G I N T */
        mI(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBIGINTEx;
        }



        /* 339:4: B I G I N T */
        mN(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBIGINTEx;
        }



        /* 339:4: B I G I N T */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBIGINTEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBIGINTEx; /* Prevent compiler warnings */
    ruleBIGINTEx: ;

}
// $ANTLR end BIGINT

//   Comes from: 343:2: ( B I T )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIT
 *
 * Looks to match the characters the constitute the token BIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBIT(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BIT;


    // SQL92.g:343:2: ( B I T )
    // SQL92.g:343:4: B I T
    {
        /* 343:4: B I T */
        mB(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBITEx;
        }



        /* 343:4: B I T */
        mI(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBITEx;
        }



        /* 343:4: B I T */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBITEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBITEx; /* Prevent compiler warnings */
    ruleBITEx: ;

}
// $ANTLR end BIT

//   Comes from: 347:2: ( B O O L E A N )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOOLEAN
 *
 * Looks to match the characters the constitute the token BOOLEAN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOOLEAN(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOOLEAN;


    // SQL92.g:347:2: ( B O O L E A N )
    // SQL92.g:347:4: B O O L E A N
    {
        /* 347:4: B O O L E A N */
        mB(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOOLEANEx;
        }



        /* 347:4: B O O L E A N */
        mO(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOOLEANEx;
        }



        /* 347:4: B O O L E A N */
        mO(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOOLEANEx;
        }



        /* 347:4: B O O L E A N */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOOLEANEx;
        }



        /* 347:4: B O O L E A N */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOOLEANEx;
        }



        /* 347:4: B O O L E A N */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOOLEANEx;
        }



        /* 347:4: B O O L E A N */
        mN(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOOLEANEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBOOLEANEx; /* Prevent compiler warnings */
    ruleBOOLEANEx: ;

}
// $ANTLR end BOOLEAN

//   Comes from: 351:2: ( B O T H )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOTH
 *
 * Looks to match the characters the constitute the token BOTH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOTH(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOTH;


    // SQL92.g:351:2: ( B O T H )
    // SQL92.g:351:4: B O T H
    {
        /* 351:4: B O T H */
        mB(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOTHEx;
        }



        /* 351:4: B O T H */
        mO(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOTHEx;
        }



        /* 351:4: B O T H */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOTHEx;
        }



        /* 351:4: B O T H */
        mH(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBOTHEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBOTHEx; /* Prevent compiler warnings */
    ruleBOTHEx: ;

}
// $ANTLR end BOTH

//   Comes from: 354:2: ( B Y )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BY
 *
 * Looks to match the characters the constitute the token BY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBY(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BY;


    // SQL92.g:354:2: ( B Y )
    // SQL92.g:354:4: B Y
    {
        /* 354:4: B Y */
        mB(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBYEx;
        }



        /* 354:4: B Y */
        mY(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleBYEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBYEx; /* Prevent compiler warnings */
    ruleBYEx: ;

}
// $ANTLR end BY

//   Comes from: 358:2: ( C A L L )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CALL
 *
 * Looks to match the characters the constitute the token CALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCALL(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CALL;


    // SQL92.g:358:2: ( C A L L )
    // SQL92.g:358:4: C A L L
    {
        /* 358:4: C A L L */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCALLEx;
        }



        /* 358:4: C A L L */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCALLEx;
        }



        /* 358:4: C A L L */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCALLEx;
        }



        /* 358:4: C A L L */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCALLEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCALLEx; /* Prevent compiler warnings */
    ruleCALLEx: ;

}
// $ANTLR end CALL

//   Comes from: 362:2: ( C A S C A D E )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CASCADE
 *
 * Looks to match the characters the constitute the token CASCADE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCASCADE(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CASCADE;


    // SQL92.g:362:2: ( C A S C A D E )
    // SQL92.g:362:4: C A S C A D E
    {
        /* 362:4: C A S C A D E */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEEx;
        }



        /* 362:4: C A S C A D E */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEEx;
        }



        /* 362:4: C A S C A D E */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEEx;
        }



        /* 362:4: C A S C A D E */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEEx;
        }



        /* 362:4: C A S C A D E */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEEx;
        }



        /* 362:4: C A S C A D E */
        mD(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEEx;
        }



        /* 362:4: C A S C A D E */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCASCADEEx; /* Prevent compiler warnings */
    ruleCASCADEEx: ;

}
// $ANTLR end CASCADE

//   Comes from: 366:2: ( C A S C A D E D )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CASCADED
 *
 * Looks to match the characters the constitute the token CASCADED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCASCADED(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CASCADED;


    // SQL92.g:366:2: ( C A S C A D E D )
    // SQL92.g:366:4: C A S C A D E D
    {
        /* 366:4: C A S C A D E D */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEDEx;
        }



        /* 366:4: C A S C A D E D */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEDEx;
        }



        /* 366:4: C A S C A D E D */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEDEx;
        }



        /* 366:4: C A S C A D E D */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEDEx;
        }



        /* 366:4: C A S C A D E D */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEDEx;
        }



        /* 366:4: C A S C A D E D */
        mD(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEDEx;
        }



        /* 366:4: C A S C A D E D */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEDEx;
        }



        /* 366:4: C A S C A D E D */
        mD(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASCADEDEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCASCADEDEx; /* Prevent compiler warnings */
    ruleCASCADEDEx: ;

}
// $ANTLR end CASCADED

//   Comes from: 370:2: ( C A S E )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CASE
 *
 * Looks to match the characters the constitute the token CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCASE(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CASE;


    // SQL92.g:370:2: ( C A S E )
    // SQL92.g:370:4: C A S E
    {
        /* 370:4: C A S E */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASEEx;
        }



        /* 370:4: C A S E */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASEEx;
        }



        /* 370:4: C A S E */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASEEx;
        }



        /* 370:4: C A S E */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASEEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCASEEx; /* Prevent compiler warnings */
    ruleCASEEx: ;

}
// $ANTLR end CASE

//   Comes from: 374:2: ( C A S T )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CAST
 *
 * Looks to match the characters the constitute the token CAST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCAST(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CAST;


    // SQL92.g:374:2: ( C A S T )
    // SQL92.g:374:4: C A S T
    {
        /* 374:4: C A S T */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASTEx;
        }



        /* 374:4: C A S T */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASTEx;
        }



        /* 374:4: C A S T */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASTEx;
        }



        /* 374:4: C A S T */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCASTEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCASTEx; /* Prevent compiler warnings */
    ruleCASTEx: ;

}
// $ANTLR end CAST

//   Comes from: 384:2: ( C H A R A C T E R )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHARACTER
 *
 * Looks to match the characters the constitute the token CHARACTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCHARACTER(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CHARACTER;


    // SQL92.g:384:2: ( C H A R A C T E R )
    // SQL92.g:384:4: C H A R A C T E R
    {
        /* 384:4: C H A R A C T E R */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



        /* 384:4: C H A R A C T E R */
        mH(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



        /* 384:4: C H A R A C T E R */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



        /* 384:4: C H A R A C T E R */
        mR(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



        /* 384:4: C H A R A C T E R */
        mA(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



        /* 384:4: C H A R A C T E R */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



        /* 384:4: C H A R A C T E R */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



        /* 384:4: C H A R A C T E R */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



        /* 384:4: C H A R A C T E R */
        mR(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCHARACTEREx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCHARACTEREx; /* Prevent compiler warnings */
    ruleCHARACTEREx: ;

}
// $ANTLR end CHARACTER

//   Comes from: 445:2: ( F R O M )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FROM
 *
 * Looks to match the characters the constitute the token FROM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFROM(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FROM;


    // SQL92.g:445:2: ( F R O M )
    // SQL92.g:445:4: F R O M
    {
        /* 445:4: F R O M */
        mF(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleFROMEx;
        }



        /* 445:4: F R O M */
        mR(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleFROMEx;
        }



        /* 445:4: F R O M */
        mO(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleFROMEx;
        }



        /* 445:4: F R O M */
        mM(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleFROMEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFROMEx; /* Prevent compiler warnings */
    ruleFROMEx: ;

}
// $ANTLR end FROM

//   Comes from: 530:2: ( S E L E C T )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SELECT
 *
 * Looks to match the characters the constitute the token SELECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSELECT(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SELECT;


    // SQL92.g:530:2: ( S E L E C T )
    // SQL92.g:530:4: S E L E C T
    {
        /* 530:4: S E L E C T */
        mS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSELECTEx;
        }



        /* 530:4: S E L E C T */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSELECTEx;
        }



        /* 530:4: S E L E C T */
        mL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSELECTEx;
        }



        /* 530:4: S E L E C T */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSELECTEx;
        }



        /* 530:4: S E L E C T */
        mC(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSELECTEx;
        }



        /* 530:4: S E L E C T */
        mT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleSELECTEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSELECTEx; /* Prevent compiler warnings */
    ruleSELECTEx: ;

}
// $ANTLR end SELECT

//   Comes from: 571:2: ( W H E R E )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHERE
 *
 * Looks to match the characters the constitute the token WHERE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHERE(pSQL92Lexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHERE;


    // SQL92.g:571:2: ( W H E R E )
    // SQL92.g:571:4: W H E R E
    {
        /* 571:4: W H E R E */
        mW(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleWHEREEx;
        }



        /* 571:4: W H E R E */
        mH(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleWHEREEx;
        }



        /* 571:4: W H E R E */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleWHEREEx;
        }



        /* 571:4: W H E R E */
        mR(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleWHEREEx;
        }



        /* 571:4: W H E R E */
        mE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleWHEREEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleWHEREEx; /* Prevent compiler warnings */
    ruleWHEREEx: ;

}
// $ANTLR end WHERE

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pSQL92Lexer ctx)
{
    {
        //  SQL92.g:1:8: ( COMMENT | ADD | ALL | ALLOCATE | ALTER | AND | ANY | ARE | AS | ASC | ASSERTION | AT | AUTHORIZATION | AVG | BEGIN | BETWEEN | BIGINT | BIT | BOOLEAN | BOTH | BY | CALL | CASCADE | CASCADED | CASE | CAST | CHARACTER | FROM | SELECT | WHERE )

        ANTLR3_UINT32 alt5;

        alt5=30;

        switch ( LA(1) )
        {
        case '/':
        	{
        		alt5=1;
        	}
            break;
        case 'A':
        case 'a':
        	{
        		switch ( LA(2) )
        		{
        		case 'D':
        		case 'd':
        			{
        				alt5=2;
        			}
        		    break;
        		case 'L':
        		case 'l':
        			{
        				switch ( LA(3) )
        				{
        				case 'L':
        				case 'l':
        					{
        						switch ( LA(4) )
        						{
        						case 'O':
        						case 'o':
        							{
        								alt5=4;
        							}
        						    break;

        						default:
        						    alt5=3;
        						}

        					}
        				    break;
        				case 'T':
        				case 't':
        					{
        						alt5=5;
        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 5;
        				    EXCEPTION->state        = 9;


        				    goto ruleTokensEx;

        				}

        			}
        		    break;
        		case 'N':
        		case 'n':
        			{
        				switch ( LA(3) )
        				{
        				case 'D':
        				case 'd':
        					{
        						alt5=6;
        					}
        				    break;
        				case 'Y':
        				case 'y':
        					{
        						alt5=7;
        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 5;
        				    EXCEPTION->state        = 10;


        				    goto ruleTokensEx;

        				}

        			}
        		    break;
        		case 'R':
        		case 'r':
        			{
        				alt5=8;
        			}
        		    break;
        		case 'S':
        		case 's':
        			{
        				switch ( LA(3) )
        				{
        				case 'C':
        				case 'c':
        					{
        						alt5=10;
        					}
        				    break;
        				case 'S':
        				case 's':
        					{
        						alt5=11;
        					}
        				    break;

        				default:
        				    alt5=9;
        				}

        			}
        		    break;
        		case 'T':
        		case 't':
        			{
        				alt5=12;
        			}
        		    break;
        		case 'U':
        		case 'u':
        			{
        				alt5=13;
        			}
        		    break;
        		case 'V':
        		case 'v':
        			{
        				alt5=14;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 5;
        		    EXCEPTION->state        = 2;


        		    goto ruleTokensEx;

        		}

        	}
            break;
        case 'B':
        case 'b':
        	{
        		switch ( LA(2) )
        		{
        		case 'E':
        		case 'e':
        			{
        				switch ( LA(3) )
        				{
        				case 'G':
        				case 'g':
        					{
        						alt5=15;
        					}
        				    break;
        				case 'T':
        				case 't':
        					{
        						alt5=16;
        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 5;
        				    EXCEPTION->state        = 16;


        				    goto ruleTokensEx;

        				}

        			}
        		    break;
        		case 'I':
        		case 'i':
        			{
        				switch ( LA(3) )
        				{
        				case 'G':
        				case 'g':
        					{
        						alt5=17;
        					}
        				    break;
        				case 'T':
        				case 't':
        					{
        						alt5=18;
        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 5;
        				    EXCEPTION->state        = 17;


        				    goto ruleTokensEx;

        				}

        			}
        		    break;
        		case 'O':
        		case 'o':
        			{
        				switch ( LA(3) )
        				{
        				case 'O':
        				case 'o':
        					{
        						alt5=19;
        					}
        				    break;
        				case 'T':
        				case 't':
        					{
        						alt5=20;
        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 5;
        				    EXCEPTION->state        = 18;


        				    goto ruleTokensEx;

        				}

        			}
        		    break;
        		case 'Y':
        		case 'y':
        			{
        				alt5=21;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 5;
        		    EXCEPTION->state        = 3;


        		    goto ruleTokensEx;

        		}

        	}
            break;
        case 'C':
        case 'c':
        	{
        		switch ( LA(2) )
        		{
        		case 'A':
        		case 'a':
        			{
        				switch ( LA(3) )
        				{
        				case 'L':
        				case 'l':
        					{
        						alt5=22;
        					}
        				    break;
        				case 'S':
        				case 's':
        					{
        						switch ( LA(4) )
        						{
        						case 'C':
        						case 'c':
        							{
        								switch ( LA(5) )
        								{
        								case 'A':
        								case 'a':
        									{
        										switch ( LA(6) )
        										{
        										case 'D':
        										case 'd':
        											{
        												switch ( LA(7) )
        												{
        												case 'E':
        												case 'e':
        													{
        														switch ( LA(8) )
        														{
        														case 'D':
        														case 'd':
        															{
        																alt5=24;
        															}
        														    break;

        														default:
        														    alt5=23;
        														}

        													}
        												    break;

        												default:
        												    CONSTRUCTEX();
        												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        												    EXCEPTION->message      = (void *)"";
        												    EXCEPTION->decisionNum  = 5;
        												    EXCEPTION->state        = 43;


        												    goto ruleTokensEx;

        												}

        											}
        										    break;

        										default:
        										    CONSTRUCTEX();
        										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        										    EXCEPTION->message      = (void *)"";
        										    EXCEPTION->decisionNum  = 5;
        										    EXCEPTION->state        = 42;


        										    goto ruleTokensEx;

        										}

        									}
        								    break;

        								default:
        								    CONSTRUCTEX();
        								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        								    EXCEPTION->message      = (void *)"";
        								    EXCEPTION->decisionNum  = 5;
        								    EXCEPTION->state        = 39;


        								    goto ruleTokensEx;

        								}

        							}
        						    break;
        						case 'E':
        						case 'e':
        							{
        								alt5=25;
        							}
        						    break;
        						case 'T':
        						case 't':
        							{
        								alt5=26;
        							}
        						    break;

        						default:
        						    CONSTRUCTEX();
        						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        						    EXCEPTION->message      = (void *)"";
        						    EXCEPTION->decisionNum  = 5;
        						    EXCEPTION->state        = 36;


        						    goto ruleTokensEx;

        						}

        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 5;
        				    EXCEPTION->state        = 20;


        				    goto ruleTokensEx;

        				}

        			}
        		    break;
        		case 'H':
        		case 'h':
        			{
        				alt5=27;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 5;
        		    EXCEPTION->state        = 4;


        		    goto ruleTokensEx;

        		}

        	}
            break;
        case 'F':
        case 'f':
        	{
        		alt5=28;
        	}
            break;
        case 'S':
        case 's':
        	{
        		alt5=29;
        	}
            break;
        case 'W':
        case 'w':
        	{
        		alt5=30;
        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 5;
            EXCEPTION->state        = 0;


            goto ruleTokensEx;

        }

        switch (alt5)
        {
    	case 1:
    	    // SQL92.g:1:10: COMMENT
    	    {
    	        /* 1:10: COMMENT */
    	        mCOMMENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // SQL92.g:1:18: ADD
    	    {
    	        /* 1:18: ADD */
    	        mADD(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // SQL92.g:1:22: ALL
    	    {
    	        /* 1:22: ALL */
    	        mALL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // SQL92.g:1:26: ALLOCATE
    	    {
    	        /* 1:26: ALLOCATE */
    	        mALLOCATE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // SQL92.g:1:35: ALTER
    	    {
    	        /* 1:35: ALTER */
    	        mALTER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // SQL92.g:1:41: AND
    	    {
    	        /* 1:41: AND */
    	        mAND(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // SQL92.g:1:45: ANY
    	    {
    	        /* 1:45: ANY */
    	        mANY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // SQL92.g:1:49: ARE
    	    {
    	        /* 1:49: ARE */
    	        mARE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // SQL92.g:1:53: AS
    	    {
    	        /* 1:53: AS */
    	        mAS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // SQL92.g:1:56: ASC
    	    {
    	        /* 1:56: ASC */
    	        mASC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // SQL92.g:1:60: ASSERTION
    	    {
    	        /* 1:60: ASSERTION */
    	        mASSERTION(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // SQL92.g:1:70: AT
    	    {
    	        /* 1:70: AT */
    	        mAT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // SQL92.g:1:73: AUTHORIZATION
    	    {
    	        /* 1:73: AUTHORIZATION */
    	        mAUTHORIZATION(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // SQL92.g:1:87: AVG
    	    {
    	        /* 1:87: AVG */
    	        mAVG(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // SQL92.g:1:91: BEGIN
    	    {
    	        /* 1:91: BEGIN */
    	        mBEGIN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // SQL92.g:1:97: BETWEEN
    	    {
    	        /* 1:97: BETWEEN */
    	        mBETWEEN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // SQL92.g:1:105: BIGINT
    	    {
    	        /* 1:105: BIGINT */
    	        mBIGINT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // SQL92.g:1:112: BIT
    	    {
    	        /* 1:112: BIT */
    	        mBIT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // SQL92.g:1:116: BOOLEAN
    	    {
    	        /* 1:116: BOOLEAN */
    	        mBOOLEAN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // SQL92.g:1:124: BOTH
    	    {
    	        /* 1:124: BOTH */
    	        mBOTH(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // SQL92.g:1:129: BY
    	    {
    	        /* 1:129: BY */
    	        mBY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // SQL92.g:1:132: CALL
    	    {
    	        /* 1:132: CALL */
    	        mCALL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // SQL92.g:1:137: CASCADE
    	    {
    	        /* 1:137: CASCADE */
    	        mCASCADE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // SQL92.g:1:145: CASCADED
    	    {
    	        /* 1:145: CASCADED */
    	        mCASCADED(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 25:
    	    // SQL92.g:1:154: CASE
    	    {
    	        /* 1:154: CASE */
    	        mCASE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 26:
    	    // SQL92.g:1:159: CAST
    	    {
    	        /* 1:159: CAST */
    	        mCAST(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 27:
    	    // SQL92.g:1:164: CHARACTER
    	    {
    	        /* 1:164: CHARACTER */
    	        mCHARACTER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 28:
    	    // SQL92.g:1:174: FROM
    	    {
    	        /* 1:174: FROM */
    	        mFROM(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 29:
    	    // SQL92.g:1:179: SELECT
    	    {
    	        /* 1:179: SELECT */
    	        mSELECT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 30:
    	    // SQL92.g:1:186: WHERE
    	    {
    	        /* 1:186: WHERE */
    	        mWHERE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
